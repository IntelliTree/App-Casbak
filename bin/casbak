#! /usr/bin/env perl
#
# Casbak main script.
#
# This is a simple wrapper around App::Casbak::Cmd.
# See that package for details and usage. (or use --help)
#
# Exit codes:
#  0 - successful operation
#  1 - no error, but no operation performed (but see --allow-noop)
#  2 - fatal error in usage or parameters
#  3 - fatal error in execution
#
# All *diagnostic* output of this command is on STDERR, including status messages
# about the progress of a backup.
#
# You will only see data on STDOUT if you request specific output, like with
#  --help, --version, or commands like 'log' or 'ls'.

use strict;
use warnings;
use Try::Tiny;
use App::Casbak::Cmd;

my %StatusCodes= (
	'success' => 0,
	'no-op'   => 1,
);

my $cmd;
try {
	my ($cmdclass, $params)= App::Casbak::Cmd->parse_argv(\@ARGV);
	my $cmd= $cmdclass->new($params);

	# App::Casbak has globally-defined logging functions, and we enable/disable them
	#  with this class method.
	App::Casbak->SetLogLevel($cmd->verbosity);

	# When trace is enabled, dump the complete internal structure of the command object
	App::Casbak::Trace($cmd);

	my $status= $cmd->run();
	die "Command returned invalid exit code: '$status'"
		unless defined $StatusCodes{$status};
	
	$status= 'success'
		if $status eq 'no-op' && $cmd->allow_no_op;

	exit $StatusCodes{$status};
}
catch {
	# Exceptions during constructor indicate invalid arguments
	if (ref $_ && ref($_)->can('pod_source')) {
		require Pod::Usage;
		Pod::Usage::pod2usage(-message => $_->message, -input => $_->pod_source, -exitcode => 2);
	} elsif (ref $_ && ref($_)->can('exit_code')) {
		print STDERR $_->message."\n";
		exit $_->exit_code;
	} else {
		chomp( my $err= "$_" );
		print STDERR "$err\n";
		# Exit with 2 if during initialization, or 3 if during execution
		exit (defined $cmd? 3 : 2);
	}
};
